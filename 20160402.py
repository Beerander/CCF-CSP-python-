"""
问题描述
　　俄罗斯方块是俄罗斯人阿列克谢·帕基特诺夫发明的一款休闲游戏。
　　游戏在一个15行10列的方格图上进行，方格图上的每一个格子可能已经放置了方块，或者没有放置方块。每一轮，都会有一个新的由4个小方块组成的板块从方格
图的上方落下，玩家可以操作板块左右移动放到合适的位置，当板块中某一个方块的下边缘与方格图上的方块上边缘重合或者达到下边界时，板块不再移动，如果此时
方格图的某一行全放满了方块，则该行被消除并得分。
　　在这个问题中，你需要写一个程序来模拟板块下落，你不需要处理玩家的操作，也不需要处理消行和得分。
　　具体的，给定一个初始的方格图，以及一个板块的形状和它下落的初始位置，你要给出最终的方格图。
输入格式
　　输入的前15行包含初始的方格图，每行包含10个数字，相邻的数字用空格分隔。如果一个数字是0，表示对应的方格中没有方块，如果数字是1，则表示初始的时
候有方块。输入保证前4行中的数字都是0。
　　输入的第16至第19行包含新加入的板块的形状，每行包含4个数字，组成了板块图案，同样0表示没方块，1表示有方块。输入保证板块的图案中正好包含4个方块
，且4个方块是连在一起的（准确的说，4个方块是四连通的，即给定的板块是俄罗斯方块的标准板块）。
　　第20行包含一个1到7之间的整数，表示板块图案最左边开始的时候是在方格图的哪一列中。注意，这里的板块图案指的是16至19行所输入的板块图案，如果板块
图案的最左边一列全是0，则它的左边和实际所表示的板块的左边是不一致的（见样例）
输出格式
　　输出15行，每行10个数字，相邻的数字之间用一个空格分隔，表示板块下落后的方格图。注意，你不需要处理最终的消行。
样例输入
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 1 0 0
0 0 0 0 0 0 1 0 0 0
0 0 0 0 0 0 1 0 0 0
1 1 1 0 0 0 1 1 1 1
0 0 0 0 1 0 0 0 0 0
0 0 0 0
0 1 1 1
0 0 0 1
0 0 0 0
3
样例输出
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 1 0 0
0 0 0 0 0 0 1 0 0 0
0 0 0 0 0 0 1 0 0 0
1 1 1 1 1 1 1 1 1 1
0 0 0 0 1 1 0 0 0 0
"""
objective = []
# 找到对应区域 15*4
gamemap = []
for _ in range(15):
    gamemap.append(list(map(int, input().split())))
recmap = []
for _ in range(4):
    recmap.append(list(map(int, input().split())))
bias = int(input())
# 对4列分别遍历，求落下的方块中每一列最下方的1与对应图中列最上方的1的距离，距离最短的最先触碰，找到该列最下方的1对应的坐标a
for col in range(bias-1, bias+3):
    recrow_1, row_1 = -1, 15
    for recrow in range(4):
        if recmap[recrow][col-bias+1]:
            recrow_1 = recrow
    for row in range(15):
        if gamemap[row][col]:
            row_1 = row
            break
    objective.append([col, row_1, recrow_1])
col, row, recrow = min(objective, key=lambda x: x[1] - x[2])  # a(col, row-1)
# 将a与方块中点坐标b作差得到正方形的左上角坐标
rec_col, rec_row = bias - 1, row - recrow - 1
# 再加上方块坐标即可得方块在图中的对应坐标
for i in range(4):
    for j in range(4):
        if rec_row+i > 14 or rec_col+j > 9:
            continue
        if recmap[i][j] and gamemap[rec_row+i][rec_col+j]:
            print('ERROR')
        if recmap[i][j]:
            gamemap[rec_row+i][rec_col+j] = recmap[i][j]
for i in range(15):
    for j in range(10):
        print(gamemap[i][j], end=' ')
    print()
